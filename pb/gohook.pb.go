// Code generated by protoc-gen-go.
// source: gohook.proto
// DO NOT EDIT!

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	gohook.proto

It has these top-level messages:
	Hook
	HookRequest
	HookCall
	TunnelRequest
	TunnelResponse
	ListRequest
	ListResponse
	CreateRequest
	CreateResponse
	DeleteRequest
	DeleteResponse
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Method defines the available http methods for setting up a webhook.
type Method int32

const (
	Method_UNKNOWN Method = 0
	Method_GET     Method = 1
	Method_POST    Method = 2
	Method_PUT     Method = 3
	Method_PATCH   Method = 4
	Method_DELETE  Method = 5
)

var Method_name = map[int32]string{
	0: "UNKNOWN",
	1: "GET",
	2: "POST",
	3: "PUT",
	4: "PATCH",
	5: "DELETE",
}
var Method_value = map[string]int32{
	"UNKNOWN": 0,
	"GET":     1,
	"POST":    2,
	"PUT":     3,
	"PATCH":   4,
	"DELETE":  5,
}

func (x Method) String() string {
	return proto.EnumName(Method_name, int32(x))
}
func (Method) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Hook defines the response of a webhook when received from the server.
type Hook struct {
	Id     string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Url    string `protobuf:"bytes,2,opt,name=url" json:"url,omitempty"`
	Method Method `protobuf:"varint,3,opt,name=method,enum=pb.Method" json:"method,omitempty"`
}

func (m *Hook) Reset()                    { *m = Hook{} }
func (m *Hook) String() string            { return proto.CompactTextString(m) }
func (*Hook) ProtoMessage()               {}
func (*Hook) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// HookRequest defines the request format when setting up a new webhook on the server.
type HookRequest struct {
	// Only a method is required when setting up a new webhook. The server
	// will set the id and return that in the response.
	Method Method `protobuf:"varint,1,opt,name=method,enum=pb.Method" json:"method,omitempty"`
}

func (m *HookRequest) Reset()                    { *m = HookRequest{} }
func (m *HookRequest) String() string            { return proto.CompactTextString(m) }
func (*HookRequest) ProtoMessage()               {}
func (*HookRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// HookCall defines the message format when receiving a hook from the tunnel.
type HookCall struct {
	Id     string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Method Method `protobuf:"varint,2,opt,name=method,enum=pb.Method" json:"method,omitempty"`
	Body   []byte `protobuf:"bytes,3,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *HookCall) Reset()                    { *m = HookCall{} }
func (m *HookCall) String() string            { return proto.CompactTextString(m) }
func (*HookCall) ProtoMessage()               {}
func (*HookCall) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type TunnelRequest struct {
}

func (m *TunnelRequest) Reset()                    { *m = TunnelRequest{} }
func (m *TunnelRequest) String() string            { return proto.CompactTextString(m) }
func (*TunnelRequest) ProtoMessage()               {}
func (*TunnelRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type TunnelResponse struct {
	// Types that are valid to be assigned to Event:
	//	*TunnelResponse_Hook
	Event isTunnelResponse_Event `protobuf_oneof:"event"`
}

func (m *TunnelResponse) Reset()                    { *m = TunnelResponse{} }
func (m *TunnelResponse) String() string            { return proto.CompactTextString(m) }
func (*TunnelResponse) ProtoMessage()               {}
func (*TunnelResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isTunnelResponse_Event interface {
	isTunnelResponse_Event()
}

type TunnelResponse_Hook struct {
	Hook *HookCall `protobuf:"bytes,1,opt,name=hook,oneof"`
}

func (*TunnelResponse_Hook) isTunnelResponse_Event() {}

func (m *TunnelResponse) GetEvent() isTunnelResponse_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *TunnelResponse) GetHook() *HookCall {
	if x, ok := m.GetEvent().(*TunnelResponse_Hook); ok {
		return x.Hook
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TunnelResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TunnelResponse_OneofMarshaler, _TunnelResponse_OneofUnmarshaler, _TunnelResponse_OneofSizer, []interface{}{
		(*TunnelResponse_Hook)(nil),
	}
}

func _TunnelResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TunnelResponse)
	// event
	switch x := m.Event.(type) {
	case *TunnelResponse_Hook:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Hook); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TunnelResponse.Event has unexpected type %T", x)
	}
	return nil
}

func _TunnelResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TunnelResponse)
	switch tag {
	case 1: // event.hook
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HookCall)
		err := b.DecodeMessage(msg)
		m.Event = &TunnelResponse_Hook{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TunnelResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TunnelResponse)
	// event
	switch x := m.Event.(type) {
	case *TunnelResponse_Hook:
		s := proto.Size(x.Hook)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ListRequest struct {
}

func (m *ListRequest) Reset()                    { *m = ListRequest{} }
func (m *ListRequest) String() string            { return proto.CompactTextString(m) }
func (*ListRequest) ProtoMessage()               {}
func (*ListRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type ListResponse struct {
	Hooks []*Hook `protobuf:"bytes,1,rep,name=hooks" json:"hooks,omitempty"`
}

func (m *ListResponse) Reset()                    { *m = ListResponse{} }
func (m *ListResponse) String() string            { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()               {}
func (*ListResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ListResponse) GetHooks() []*Hook {
	if m != nil {
		return m.Hooks
	}
	return nil
}

type CreateRequest struct {
	Hook *HookRequest `protobuf:"bytes,1,opt,name=hook" json:"hook,omitempty"`
}

func (m *CreateRequest) Reset()                    { *m = CreateRequest{} }
func (m *CreateRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateRequest) ProtoMessage()               {}
func (*CreateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *CreateRequest) GetHook() *HookRequest {
	if m != nil {
		return m.Hook
	}
	return nil
}

type CreateResponse struct {
	Hook *Hook `protobuf:"bytes,1,opt,name=hook" json:"hook,omitempty"`
}

func (m *CreateResponse) Reset()                    { *m = CreateResponse{} }
func (m *CreateResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateResponse) ProtoMessage()               {}
func (*CreateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CreateResponse) GetHook() *Hook {
	if m != nil {
		return m.Hook
	}
	return nil
}

type DeleteRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *DeleteRequest) Reset()                    { *m = DeleteRequest{} }
func (m *DeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteRequest) ProtoMessage()               {}
func (*DeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type DeleteResponse struct {
	Hook *Hook `protobuf:"bytes,1,opt,name=hook" json:"hook,omitempty"`
}

func (m *DeleteResponse) Reset()                    { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()               {}
func (*DeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *DeleteResponse) GetHook() *Hook {
	if m != nil {
		return m.Hook
	}
	return nil
}

func init() {
	proto.RegisterType((*Hook)(nil), "pb.Hook")
	proto.RegisterType((*HookRequest)(nil), "pb.HookRequest")
	proto.RegisterType((*HookCall)(nil), "pb.HookCall")
	proto.RegisterType((*TunnelRequest)(nil), "pb.TunnelRequest")
	proto.RegisterType((*TunnelResponse)(nil), "pb.TunnelResponse")
	proto.RegisterType((*ListRequest)(nil), "pb.ListRequest")
	proto.RegisterType((*ListResponse)(nil), "pb.ListResponse")
	proto.RegisterType((*CreateRequest)(nil), "pb.CreateRequest")
	proto.RegisterType((*CreateResponse)(nil), "pb.CreateResponse")
	proto.RegisterType((*DeleteRequest)(nil), "pb.DeleteRequest")
	proto.RegisterType((*DeleteResponse)(nil), "pb.DeleteResponse")
	proto.RegisterEnum("pb.Method", Method_name, Method_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for Gohook service

type GohookClient interface {
	// Tunnel initiates an open connection between the client and server.
	// This is used to stream data from the server to the client when
	// specific events happen that the client needs to know about. This
	// includes when one of the webhook ids is hit so the client can
	// execute the script paired with that hook id.
	Tunnel(ctx context.Context, in *TunnelRequest, opts ...grpc.CallOption) (Gohook_TunnelClient, error)
	// List returns all of the webhooks that are tied to this client.
	// This allows the client to stay synced with the webhooks that are
	// enabled and ones that have been removed.
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
	// Create sets up a new webhook on the server.
	// This is used to tell the server to set up a webhook and inform
	// us over the tunnel stream when that webhook it hit.
	Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error)
	// Delete removes a webhook from the server for this client.
	// This allows the client to unsubscribe when it no longer cares about
	// the restults of a webhook getting hit.
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
}

type gohookClient struct {
	cc *grpc.ClientConn
}

func NewGohookClient(cc *grpc.ClientConn) GohookClient {
	return &gohookClient{cc}
}

func (c *gohookClient) Tunnel(ctx context.Context, in *TunnelRequest, opts ...grpc.CallOption) (Gohook_TunnelClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Gohook_serviceDesc.Streams[0], c.cc, "/pb.Gohook/Tunnel", opts...)
	if err != nil {
		return nil, err
	}
	x := &gohookTunnelClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Gohook_TunnelClient interface {
	Recv() (*TunnelResponse, error)
	grpc.ClientStream
}

type gohookTunnelClient struct {
	grpc.ClientStream
}

func (x *gohookTunnelClient) Recv() (*TunnelResponse, error) {
	m := new(TunnelResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gohookClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	out := new(ListResponse)
	err := grpc.Invoke(ctx, "/pb.Gohook/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gohookClient) Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error) {
	out := new(CreateResponse)
	err := grpc.Invoke(ctx, "/pb.Gohook/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gohookClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := grpc.Invoke(ctx, "/pb.Gohook/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Gohook service

type GohookServer interface {
	// Tunnel initiates an open connection between the client and server.
	// This is used to stream data from the server to the client when
	// specific events happen that the client needs to know about. This
	// includes when one of the webhook ids is hit so the client can
	// execute the script paired with that hook id.
	Tunnel(*TunnelRequest, Gohook_TunnelServer) error
	// List returns all of the webhooks that are tied to this client.
	// This allows the client to stay synced with the webhooks that are
	// enabled and ones that have been removed.
	List(context.Context, *ListRequest) (*ListResponse, error)
	// Create sets up a new webhook on the server.
	// This is used to tell the server to set up a webhook and inform
	// us over the tunnel stream when that webhook it hit.
	Create(context.Context, *CreateRequest) (*CreateResponse, error)
	// Delete removes a webhook from the server for this client.
	// This allows the client to unsubscribe when it no longer cares about
	// the restults of a webhook getting hit.
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
}

func RegisterGohookServer(s *grpc.Server, srv GohookServer) {
	s.RegisterService(&_Gohook_serviceDesc, srv)
}

func _Gohook_Tunnel_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TunnelRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GohookServer).Tunnel(m, &gohookTunnelServer{stream})
}

type Gohook_TunnelServer interface {
	Send(*TunnelResponse) error
	grpc.ServerStream
}

type gohookTunnelServer struct {
	grpc.ServerStream
}

func (x *gohookTunnelServer) Send(m *TunnelResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Gohook_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GohookServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Gohook/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GohookServer).List(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gohook_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GohookServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Gohook/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GohookServer).Create(ctx, req.(*CreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gohook_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GohookServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Gohook/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GohookServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Gohook_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Gohook",
	HandlerType: (*GohookServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _Gohook_List_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _Gohook_Create_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Gohook_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Tunnel",
			Handler:       _Gohook_Tunnel_Handler,
			ServerStreams: true,
		},
	},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("gohook.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 425 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x93, 0x51, 0x6f, 0xd3, 0x30,
	0x14, 0x85, 0xeb, 0x24, 0x4d, 0xbb, 0x9b, 0x36, 0x33, 0xf7, 0x29, 0x9a, 0x10, 0x54, 0xe6, 0xa5,
	0x02, 0x29, 0x62, 0x19, 0xaf, 0x3c, 0x40, 0x17, 0x2d, 0x12, 0xa5, 0xab, 0x42, 0x26, 0x9e, 0x17,
	0xc5, 0x62, 0xd5, 0x42, 0x1c, 0x9a, 0x14, 0x89, 0x7f, 0xc9, 0x4f, 0x42, 0xb6, 0x63, 0xd2, 0x80,
	0x2a, 0xed, 0xcd, 0x3d, 0xbe, 0xe7, 0x9c, 0xab, 0xcf, 0x0d, 0xcc, 0xbe, 0x89, 0x07, 0x21, 0x1e,
	0xc3, 0x7a, 0x2f, 0x5a, 0x81, 0x56, 0x9d, 0xb3, 0x35, 0x38, 0x89, 0x10, 0x8f, 0xe8, 0x83, 0xb5,
	0x2b, 0x02, 0xb2, 0x20, 0xcb, 0xb3, 0xd4, 0xda, 0x15, 0x48, 0xc1, 0x3e, 0xec, 0xcb, 0xc0, 0x52,
	0x82, 0x3c, 0x22, 0x03, 0xf7, 0x3b, 0x6f, 0x1f, 0x44, 0x11, 0xd8, 0x0b, 0xb2, 0xf4, 0x23, 0x08,
	0xeb, 0x3c, 0xfc, 0xac, 0x94, 0xb4, 0xbb, 0x61, 0x97, 0xe0, 0xc9, 0xb4, 0x94, 0xff, 0x38, 0xf0,
	0xa6, 0x3d, 0xb2, 0x90, 0x93, 0x96, 0x14, 0xa6, 0xd2, 0xb2, 0xba, 0x2f, 0xcb, 0xff, 0x96, 0xe8,
	0xfd, 0xd6, 0x29, 0x3f, 0x22, 0x38, 0xb9, 0x28, 0x7e, 0xa9, 0xa5, 0x66, 0xa9, 0x3a, 0xb3, 0x73,
	0x98, 0x67, 0x87, 0xaa, 0xe2, 0x65, 0xb7, 0x08, 0x7b, 0x0f, 0xbe, 0x11, 0x9a, 0x5a, 0x54, 0x0d,
	0x47, 0x06, 0x8e, 0x24, 0xa1, 0xca, 0xbc, 0x68, 0x26, 0x83, 0xcd, 0x1a, 0xc9, 0x28, 0x55, 0x77,
	0x1f, 0x27, 0x30, 0xe6, 0x3f, 0x79, 0xd5, 0xb2, 0x39, 0x78, 0xeb, 0x5d, 0xd3, 0x9a, 0xb4, 0x10,
	0x66, 0xfa, 0x67, 0x97, 0xf5, 0x02, 0xc6, 0x72, 0xbe, 0x09, 0xc8, 0xc2, 0x5e, 0x7a, 0xd1, 0xd4,
	0x84, 0xa5, 0x5a, 0x66, 0xef, 0x60, 0xbe, 0xda, 0xf3, 0xfb, 0x96, 0x1b, 0x2e, 0xaf, 0x06, 0xe5,
	0xe7, 0x7f, 0xe7, 0xf5, 0xb5, 0x6e, 0x67, 0x21, 0xf8, 0xc6, 0xd5, 0xf5, 0x3c, 0x1f, 0xd8, 0xfa,
	0x1a, 0x3d, 0xff, 0x12, 0xe6, 0xd7, 0xbc, 0xe4, 0x7d, 0xcb, 0x3f, 0x34, 0x65, 0xa0, 0x19, 0x78,
	0x4a, 0xe0, 0xeb, 0x04, 0x5c, 0xcd, 0x1a, 0x3d, 0x98, 0xdc, 0x6d, 0x3e, 0x6d, 0x6e, 0xbf, 0x6e,
	0xe8, 0x08, 0x27, 0x60, 0xdf, 0xc4, 0x19, 0x25, 0x38, 0x05, 0x67, 0x7b, 0xfb, 0x25, 0xa3, 0x96,
	0x94, 0xb6, 0x77, 0x19, 0xb5, 0xf1, 0x0c, 0xc6, 0xdb, 0x0f, 0xd9, 0x2a, 0xa1, 0x0e, 0x02, 0xb8,
	0xd7, 0xf1, 0x3a, 0xce, 0x62, 0x3a, 0x8e, 0x7e, 0x13, 0x70, 0x6f, 0xd4, 0x3f, 0x0f, 0xaf, 0xc0,
	0xd5, 0x2f, 0x81, 0xcf, 0x64, 0xdd, 0xe0, 0x99, 0x2e, 0xf0, 0x58, 0xd2, 0x3b, 0xb2, 0xd1, 0x5b,
	0x82, 0x6f, 0xc0, 0x91, 0xc0, 0x51, 0x91, 0x3a, 0x7a, 0x89, 0x0b, 0xda, 0x0b, 0x66, 0x1c, 0x2f,
	0xc1, 0xd5, 0xdc, 0x74, 0xc3, 0x80, 0xbc, 0x6e, 0x18, 0x62, 0xd5, 0x16, 0x4d, 0x46, 0x5b, 0x06,
	0x18, 0xb5, 0x65, 0x08, 0x8e, 0x8d, 0x72, 0x57, 0x7d, 0x42, 0x57, 0x7f, 0x02, 0x00, 0x00, 0xff,
	0xff, 0x15, 0x6e, 0x77, 0x75, 0x52, 0x03, 0x00, 0x00,
}
